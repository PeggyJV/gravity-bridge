syntax = "proto3";
package gravity.v2;

import "cosmos/base/v1beta1/coin.proto";
import "cosmos_proto/cosmos.proto";
import "gravity/v2/gravity.proto";
import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/peggyjv/gravity-bridge/module/v3/x/gravity/types";

// Msg defines the state transitions possible within gravity
service Msg {
  rpc SetDelegateKeys(MsgDelegateKeys) returns (MsgDelegateKeysResponse) {}
  rpc SendToEVM(MsgSendToEVM) returns (MsgSendToEVMResponse) {}
  rpc CancelSendToEVM(MsgCancelSendToEVM)
      returns (MsgCancelSendToEVMResponse) {}
  rpc RequestBatchTx(MsgRequestBatchTx) returns (MsgRequestBatchTxResponse) {}
  rpc SubmitEVMTxConfirmation(MsgSubmitEVMTxConfirmation)
      returns (MsgSubmitEVMTxConfirmationResponse) {}
  rpc SubmitEVMEvent(MsgSubmitEVMEvent)
      returns (MsgSubmitEVMEventResponse) {}
  rpc SubmitEVMHeightVote(MsgEVMHeightVote)
      returns (MsgEVMHeightVoteResponse) {
  }
}

// MsgSendToEVM submits a SendToEVM attempt to bridge an asset over to
// EVM. The SendToEVM will be stored and then included in a batch and
// then submitted to EVM.
message MsgSendToEVM {
  string sender = 1;
  string EVM_recipient = 2;
  cosmos.base.v1beta1.Coin amount = 3 [ (gogoproto.nullable) = false ];
  cosmos.base.v1beta1.Coin bridge_fee = 4 [ (gogoproto.nullable) = false ];
  uint32 chain_id = 5;
}

// MsgSendToEVMResponse returns the SendToEVM transaction ID which
// will be included in the batch tx.
message MsgSendToEVMResponse {
  uint64 id = 1;
}

// MsgCancelSendToEVM allows the sender to cancel its own outgoing
// SendToEVM tx and receive a refund of the tokens and bridge fees. This tx
// will only succeed if the SendToEVM tx hasn't been batched to be
// processed and relayed to EVM.
message MsgCancelSendToEVM {
  uint64 id = 1;
  string sender = 2;
  uint32 chain_id = 3;
}

message MsgCancelSendToEVMResponse {}

// MsgRequestBatchTx requests a batch of transactions with a given coin
// denomination to send across the bridge to EVM.
message MsgRequestBatchTx {
  string denom = 1;
  string signer = 2;
  uint32 chain_id = 3;
}

message MsgRequestBatchTxResponse {}

// MsgSubmitEVMTxConfirmation submits an EVM signature for a given
// validator
message MsgSubmitEVMTxConfirmation {
  option (gogoproto.goproto_getters) = false;

  // TODO: can we make this take an array?
  google.protobuf.Any confirmation = 1
  [ (cosmos_proto.accepts_interface) = "EVMTxConfirmation" ];
  string signer = 2;
  uint32 chain_id = 3;
}

// ContractCallTxConfirmation is a signature on behalf of a validator for a
// ContractCallTx.
message ContractCallTxConfirmation {
  bytes invalidation_scope = 1;
  uint64 invalidation_nonce = 2;
  string EVM_signer = 3;
  bytes signature = 4;
  uint32 chain_id = 5;
}

// BatchTxConfirmation is a signature on behalf of a validator for a BatchTx.
message BatchTxConfirmation {
  string token_contract = 1;
  uint64 batch_nonce = 2;
  string EVM_signer = 3;
  bytes signature = 4;
  uint32 chain_id = 5;
}

// SignerSetTxConfirmation is a signature on behalf of a validator for a
// SignerSetTx
message SignerSetTxConfirmation {
  uint64 signer_set_nonce = 1;
  string EVM_signer = 2;
  bytes signature = 3;
  uint32 chain_id = 4;
}

message MsgSubmitEVMTxConfirmationResponse {}

// MsgSubmitEVMEvent
message MsgSubmitEVMEvent {
  option (gogoproto.goproto_getters) = false;

  google.protobuf.Any event = 1
  [ (cosmos_proto.accepts_interface) = "EVMEvent" ];
  string signer = 2;
  uint32 chain_id = 3;
}

message MsgSubmitEVMEventResponse {}


// MsgDelegateKeys allows validators to delegate their voting responsibilities
// to a given orchestrator address. This key is then used as an optional
// authentication method for attesting events from EVM.
message MsgDelegateKeys {
  string validator_address = 1;
  string orchestrator_address = 2;
  string EVM_address = 3;
  bytes eth_signature = 4;
}

message MsgDelegateKeysResponse {}

// DelegateKeysSignMsg defines the message structure an operator is expected to
// sign when submitting a MsgDelegateKeys message. The resulting signature
// should populate the eth_signature field.
message DelegateKeysSignMsg {
  string validator_address = 1;
  uint64 nonce = 2;
}

// Periodic update of latest observed EVM and Cosmos heights from the
// orchestrator
message MsgEVMHeightVote {
  uint64 evm_height = 1;
  string signer = 2;
  uint32 chain_id = 3;
}

message MsgEVMHeightVoteResponse {}


////////////
// Events //
////////////

// SendToCosmosEvent is submitted when the SendToCosmosEvent is emitted by they
// gravity contract. ERC20 representation coins are minted to the cosmosreceiver
// address.
message SendToCosmosEvent {
  option (gogoproto.equal) = true;
  uint64 event_nonce = 1;
  string token_contract = 2;
  string amount = 3 [
    (gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int",
    (gogoproto.nullable) = false
  ];
  string EVM_sender = 4;
  string cosmos_receiver = 5;
  uint64 EVM_height = 6;
  uint32 chain_id = 7;
}

// BatchExecutedEvent claims that a batch of BatchTxExecutedal operations on the
// bridge contract was executed successfully on ETH
message BatchExecutedEvent {
  string token_contract = 1;
  uint64 event_nonce = 2;
  uint64 EVM_height = 3;
  uint64 batch_nonce = 4;
  uint32 chain_id = 5;
}

// ContractCallExecutedEvent describes a contract call that has been
// successfully executed on EVM.

// NOTE: bytes.HexBytes is supposed to "help" with json encoding/decoding
// investigate?
message ContractCallExecutedEvent {
  uint64 event_nonce = 1;
  bytes invalidation_scope = 2
  [ (gogoproto.casttype) =
      "github.com/tendermint/tendermint/libs/bytes.HexBytes" ];
  uint64 invalidation_nonce = 3;
  uint64 EVM_height = 4;
  uint32 chain_id = 5;
}

// ERC20DeployedEvent is submitted when an ERC20 contract
// for a Cosmos SDK coin has been deployed on EVM.
message ERC20DeployedEvent {
  uint64 event_nonce = 1;
  string cosmos_denom = 2;
  string token_contract = 3;
  string erc20_name = 4;
  string erc20_symbol = 5;
  uint64 erc20_decimals = 6;
  uint64 EVM_height = 7;
  uint32 chain_id = 8;
}

// This informs the Cosmos module that a validator
// set has been updated.
message SignerSetTxExecutedEvent {
  uint64 event_nonce = 1;
  uint64 signer_set_tx_nonce = 2;
  uint64 EVM_height = 3;
  repeated EVMSigner members = 4;
  uint32 chain_id = 5;
}
